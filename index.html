<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Sender/Receiver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        textarea {
            width: 100%;
            height: 100px;
            font-size: 16px;
            margin-top: 10px;
        }
        button {
            font-size: 18px;
            margin-top: 10px;
            padding: 10px;
        }
        video {
            width: 100%;
            max-width: 1280px;
            margin-top: 20px;
        }
        .container {
            margin-bottom: 20px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1 id="roleTitle">WebRTC Setup</h1>
    <button id="startSenderButton">Start Sender</button>
    <button id="startReceiverButton">Start Receiver</button>

    <video id="video" autoplay loop muted></video>
    <p>Current Bitrate: <span id="bitrate">Calculating...</span></p>

    <!-- Offer from the sender -->
    <div id="offerContainer" class="container hidden">
        <textarea id="offer" placeholder="OFFER (computing...)" readonly></textarea>
        <button id="copyOfferButton">Copy Offer</button>
    </div>

    <!-- Offer pasted into the receiver -->
    <div id="offerFromPeerContainer" class="container hidden">
        <textarea id="offerFromPeer" placeholder="OFFER FROM PEER"></textarea>
        <button id="pasteOfferButton">Paste Offer</button>
    </div>

    <!-- Answer generated by the receiver -->
    <div id="answerContainer" class="container hidden">
        <textarea id="answer" placeholder="ANSWER (after Offer From Peer)" readonly></textarea>
        <button id="copyAnswerButton">Copy Answer</button>
    </div>

    <!-- Answer pasted back into the sender -->
    <div id="answerFromPeerContainer" class="container hidden">
        <textarea id="answerFromPeer" placeholder="ANSWER FROM PEER"></textarea>
        <button id="pasteAnswerButton">Paste Answer</button>
    </div>

    <script>
        let isSender = false;
        const videoElement = document.getElementById('video');
        const roleTitle = document.getElementById('roleTitle');
        const offerContainer = document.getElementById('offerContainer');
        const offerElement = document.getElementById('offer');
        const offerFromPeerContainer = document.getElementById('offerFromPeerContainer');
        const offerFromPeerElement = document.getElementById('offerFromPeer');
        const answerContainer = document.getElementById('answerContainer');
        const answerElement = document.getElementById('answer');
        const answerFromPeerContainer = document.getElementById('answerFromPeerContainer');
        const answerFromPeerElement = document.getElementById('answerFromPeer');
        const bitrateElement = document.getElementById('bitrate');
        const startSenderButton = document.getElementById('startSenderButton');
        const startReceiverButton = document.getElementById('startReceiverButton');
        const copyOfferButton = document.getElementById('copyOfferButton');
        const pasteOfferButton = document.getElementById('pasteOfferButton');
        const copyAnswerButton = document.getElementById('copyAnswerButton');
        const pasteAnswerButton = document.getElementById('pasteAnswerButton');
        let lastBytes = 0;
        let peerConnection;
        let iceGatheringTimeout;

        startSenderButton.addEventListener('click', () => {
            isSender = true;
            roleTitle.textContent = "Running as Sender";
            offerContainer.classList.remove('hidden');
            answerFromPeerContainer.classList.remove('hidden');
            setupWebRTC(true);
        });

        startReceiverButton.addEventListener('click', () => {
            isSender = false;
            roleTitle.textContent = "Running as Receiver";
            offerFromPeerContainer.classList.remove('hidden');
            answerContainer.classList.remove('hidden');
            setupWebRTC(false);
        });

        async function setupWebRTC(createOffer = false) {
			peerConnection = new RTCPeerConnection({
				iceServers: [
					{ urls: 'stun:stun.l.google.com:19302' }
				]
			});
			
            peerConnection.onicecandidate = event => {
                if (!event.candidate) {
                    clearTimeout(iceGatheringTimeout);
                    finalizeOfferOrAnswer();
                }
            };

            iceGatheringTimeout = setTimeout(() => {
                finalizeOfferOrAnswer();
            }, 10000);  // 10 seconds timeout for ICE gathering

            if (isSender) {
                let videoSource;

                // Determine the video source based on the current hostname
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    videoSource = window.location.origin + "/sintel_trailer-1080p.mp4";
                } else {
                    videoSource = "https://download.blender.org/durian/trailer/sintel_trailer-1080p.mp4";
                }
				
				

                videoElement.src = videoSource;
                await videoElement.play();

                const stream = videoElement.captureStream();
				stream.getTracks().forEach(track => {
					peerConnection.addTrack(track, stream);
				});

				if (createOffer) {
					const offer = await peerConnection.createOffer();

					// Modify the SDP to prioritize H.264 and ensure higher bitrate
					let modifiedSDP = offer.sdp;

					// Reorder codecs: move H.264 (payload type 102) before VP8 (payload type 96)
					modifiedSDP = modifiedSDP.replace(
						/m=video (\d+) UDP\/TLS\/RTP\/SAVPF 96 97 102/g,
						'm=video $1 UDP/TLS/RTP/SAVPF 102 97 96'
					);
					// Insert a line to set maximum bandwidth (bitrate) for video
					modifiedSDP = modifiedSDP.replace(/a=mid:1\r\n/g, 'a=mid:1\r\nb=AS:5000\r\n');

					// Modify H.264 codec to enforce higher bitrates (if using H.264)
					modifiedSDP = modifiedSDP.replace(/a=rtpmap:102 H264\/90000\r\n/g, 'a=rtpmap:102 H264/90000\r\na=fmtp:102 max-fs=8160;max-fr=30;x-google-min-bitrate=3000; x-google-max-bitrate=5000;\r\n');

					// Apply the modified SDP back to the peer connection
					const modifiedOffer = new RTCSessionDescription({
						type: offer.type,
						sdp: modifiedSDP
					});

					await peerConnection.setLocalDescription(modifiedOffer);
				}
			}

            offerFromPeerElement.addEventListener('input', async () => {
                const offer = JSON.parse(offerFromPeerElement.value);
                await peerConnection.setRemoteDescription(offer);

                if (!isSender) {
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                }
            });

            answerFromPeerElement.addEventListener('input', async () => {
                const answer = JSON.parse(answerFromPeerElement.value);
                await peerConnection.setRemoteDescription(answer);
            });

            if (!isSender) {
                peerConnection.onaddstream = event => {
                    videoElement.srcObject = event.stream;
                };
                monitorBitrate('inbound-rtp');
            }
        }

        function finalizeOfferOrAnswer() {
            if (isSender) {
                offerElement.value = JSON.stringify(peerConnection.localDescription);
            } else {
                answerElement.value = JSON.stringify(peerConnection.localDescription);
            }
        }

        function monitorBitrate(type) {
            setInterval(() => {
                peerConnection.getStats().then(stats => {
                    stats.forEach(report => {
                        if (report.type === type && (report.bytesSent || report.bytesReceived)) {
                            const bytes = report.bytesSent || report.bytesReceived;
                            const bitrate = ((bytes - lastBytes) * 8) / 1000; // kbps
                            bitrateElement.textContent = `${bitrate.toFixed(2)} kbps`;
                            lastBytes = bytes;
                        }
                    });
                });
            }, 1000);
        }

        // Copy/Paste functionality
        copyOfferButton.addEventListener('click', () => {
            navigator.clipboard.writeText(offerElement.value);
        });

        pasteOfferButton.addEventListener('click', async () => {
            const text = await navigator.clipboard.readText();
            offerFromPeerElement.value = text;
            offerFromPeerElement.dispatchEvent(new Event('input'));
        });

        copyAnswerButton.addEventListener('click', () => {
            navigator.clipboard.writeText(answerElement.value);
        });

        pasteAnswerButton.addEventListener('click', async () => {
            const text = await navigator.clipboard.readText();
            answerFromPeerElement.value = text;
            answerFromPeerElement.dispatchEvent(new Event('input'));
        });
    </script>
</body>
</html>
